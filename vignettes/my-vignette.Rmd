---
title: "my-vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(corrRank)
```

## Introduction

When working with a new dataset, you often want to understand which variables are related and how. Before beginning a linear regression analysis, you may also want to explore relationships between potential predictors and outcomes. Manually analyzing each pair of correlations takes time and effort. The corrRank package speeds up this process by providing useful summaries and visualizations of predictor-outcome correlations.

With corrRank, you can quickly discover:

* The predictor with the strongest (and weakest) association with your outcome
* Which correlations are significant
* The strength and direction of associations
* A scatterplot of the predictor-outcome relationship

## Data: Cities

The package has a built-in dataset, `cities`, which we will use to explore the package's function. The data measures various aspects of wellness in `r nrow(cities)` European cities.

## Function: `corrRank()`

The `corrRank` function takes two inputs: a list of named predictor vectors and a single outcome vector. All predictors and the outcome must be numeric variables (preferably continuous) to perform the correlation analysis. 

In the `cities` data, let's say we want to explore which factors are associated with a city's happiness level (`happiness_level`). Based on background knowledge, we believe that average hours worked annually (`avg_hours_worked_annual`), pollution (`pollution_index`) and number of hours of sunshine per year (`sunshine_hours`) may be associated with happiness. Using corrRank(), we write:

```{r}
corrRank(list(Work = cities$avg_hours_worked_annual, 
              Pollution = cities$pollution_index, 
              Sunshine = cities$sunshine_hours), 
              cities$happiness_level)
```

The output is a dataframe listing the predictors in order of strongest to weakest linear association with happiness level (by absolute value), as well as the correlation value, its significance, and a description of the correlation. Positive correlations mean that as the predictor increases, the outcome tends to increase as well. Negative correlations mean that as the predictor increases, the outcome tends to decrease.

In this example, the `pollution_index` has the strongest linear association with happiness at `r=-0.77`. Pollution and happiness are negatively related - increases in pollution are associated with decreases in happiness, which makes sense. This association is significant and considered moderately strong. 

Predictors with a higher rank may be worth exploring further. However, a high correlation value doesn't mean that predictor will be significant in a multiple linear regression setting. `corrRank()` is an exploratory tool to get you started on pairwise associations, but shouldn't be used to make decisions on more complex regression modelling.

Inside `corrRank()`, make sure to specify a name for each predictor (ie. `Work = __, Pollution = ___, Sunshine = ___` and include all predictors inside of one list (ie. `list(___)`. The outcome of interest should remain in vector format and doesn't need to be named.

## Function: `cplot()`

The `cplot` function takes two arguments: a list of predictor vectors and a single outcome variable, consistent with arguments for `corrRank()`. Similarly, all predictors and the outcome must be numeric.

The function outputs a predictor-outcome scatterplot for each predictor vector in the list of predictors. The order of scatterplot output is determined by the order of predictor vectors listed. A line of best fit and pearson correlation coefficient accompanies the correlation plot.

From the `cities` dataset, we can visualize the correlation for a list of predictors: average hours worked annually (`avg_hours_worked_annual`), pollution (`pollution_index`) and number of hours of sunshine per year (`sunshine_hours`), against the outcome, 'happiness level'. Using `cplot()` we write:

```{r}
# "exposures" is an assigned list of predictors
exposures <- list(Work = cities$avg_hours_worked_annual, Pollution = cities$pollution_index, Sunshine = cities$sunshine_hours)

cplot(exposures, cities$happiness_level)
```


Individual scatterplots can be extracted for each predictor using the order that they are listed in. In the `cities` dataset, `cplot()` takes the list of predictors `exposures` which consists of (1) average hours worked annually, (2) pollution, and (3) annual hours of sunshine, embedded in that order. To extract individual scatterplots, we write:

```{r}
plots <- cplot(exposures, cities$happiness_level)

# scatter plot: average hours worked annually vs. happiness level
plots$`Exposure 1`

# scatter plot: pollution vs. happiness level
plots$`Exposure 2`

# scatterplot: annual hours of sunshine vs. happiness level
plots$`Exposure 3`
```

The function `cplot()` can also generate scatterplots that exclude the line of best fit and the correlation output by specifying *line = F* and *r = F* respectively. Furthermore, the title and title axes can be modified according to `ggplot2` labeling conventions. Following the `cities` examples, to extract a scatterplot for annual hours of sunshine against happiness level, relabel the plot, and exclude the line of best fit, we write:

```{r}
plot_list <- cplot(exposures, cities$happiness_level, line = F)
plot_list$`Exposure 3` + ggplot2::labs(x = "Annual Hours of Sunshine",
                              y = "Happiness Level",
                              title = "Correlation Between Annual Hours of Sunshine and Happiness Level")
```
